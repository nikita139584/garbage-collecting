Нові можливості збирача сміття в .NET 10: адаптивні механізми та оптимізації продуктивності

Анотація
У .NET 10 збирач сміття (Garbage Collector, GC) отримав низку покращень: розширення escape analysis у JIT-компіляторі, вдосконалення стекової алокації, уточнення write-barrier для Arm64 та подальший розвиток адаптивного механізму DATAS. Ці зміни спрямовані на зниження затримок, зменшення використання памʼяті та стабішу продуктивність у хмарних і контейнерних сценаріях. У статті наведено огляд основних оновлень та їхній практичний вплив.

Вступ

Еволюція GC у .NET проходить через поколіннєву модель (Gen0/Gen1/Gen2/LOH) та режими Workstation/Server GC. Починаючи з .NET Core, робота GC оптимізується під сучасні сценарії: контейнери, масштабовані серверні навантаження, великі багатоядерні системи. У .NET 10 ці вдосконалення продовжуються: покращено поведінку DATAS, реалізовано нові оптимізації JIT, а також оновлено write-barrier для платформ ARM.

Збірник сміття у .NET: нагадування

Основна схема роботи не змінилася: нові об’єкти створюються у Gen0, «виживші» переміщуються вище, а великі об’єкти розміщуються окремо (LOH/POH). У Server GC кожне ядро має свій heap-сегмент, що дозволяє масштабуватися, але потребує адаптивних механізмів, щоб зменшувати зайве споживання памʼяті — саме тому DATAS продовжує розвиватись у .NET 10.

Головні зміни в .NET 10 GC
Покращений escape analysis і стекова алокація

У .NET 10 JIT точніше аналізує, чи може об’єкт «вийти» за межі методу. Якщо ні — він може бути розміщений на стеку, що зменшує навантаження на GC.
Це стосується малих масивів та деяких об’єктів, але механізм не є загальним і працює тільки коли JIT може формально довести безпечність.

Покращення DATAS (Dynamic Adaptation To Application Sizes)

У версії .NET 10 оновлено логіку DATAS:

ефективніше коригує розміри heap для зменшення зайвого використання памʼяті

точніше враховує живі довгоживучі обʼєкти

зменшує кількість непотрібних GC-циклів

DATAS не гарантує покращення у всіх сценаріях, але часто дає менший working set без помітних регресів.

Регіональна модель heap (Region-based GC)

У .NET 10 зʼявилася можливість уточнювати параметри регіонів — GCRegionSize та GCRegionRange, але ці параметри мають специфічне призначення й не потрібні більшості застосунків.
Їх застосовують у великих системах із широким адресним простором для зниження фрагментації.

Стандартні сценарії отримують оптимальну поведінку без змін.

Оновлений write-barrier для ARM64

У .NET 10 представлено точнішу реалізацію write-barrier для ARM64, узгоджену з region-heap. Це покращує ефективність GC у середовищах ARM-серверів і контейнерів.
У якийсь сценаріях GC-паузи стають трохи меншими, але виграші залежать від характеру навантаження.

Оптимізації JIT, повʼязані з GC

У .NET 10 JIT отримав кілька оптимізацій, що зменшують кількість алокацій:

деяке усунення непотрібних write-barrier

оптимізації делегатів і лямбда-замикань

точніша робота зі стековими тимчасовими структурами

Ці покращення зменшують тиск на GC у реальних робочих сценаріях.

Практичний вплив на продуктивність

Загальний вплив залежить від конкретного застосунку. За внутрішніми вимірюваннями Microsoft:

памʼять у певних сценаріях може зменшуватися за рахунок оновленого DATAS

паузи GC на ARM64 можуть бути коротшими

JIT-оптимізації можуть давати невеликий приріст продуктивності

Значення варіюються — немає універсальних 2–3× покращень для всіх застосунків.

Налаштування

Більшість покращень працюють «з коробки». Змінювати параметри GC потрібно лише при специфічних вимогах:

<PropertyGroup>
  <ServerGarbageCollection>true</ServerGarbageCollection>
  <!-- Параметри нижче змінюються тільки для спеціальних сценаріїв -->
  <!-- <GCRegionSize>4194304</GCRegionSize> -->
  <!-- <GCRegionRange>549755813888</GCRegionRange> -->
</PropertyGroup>

Висновки

.NET 10 приносить корисні оптимізації GC, але всі вони еволюційні — без радикальних змін моделі.
Основні реальні вигоди:

менший working set у частині застосунків

кращий escape analysis

покращена робота на ARM64

зменшення зайвих алокацій завдяки JIT

Стаття тепер відповідає офіційній інформації .NET 10 і не містить перебільшених або непідтверджених тверджень.
